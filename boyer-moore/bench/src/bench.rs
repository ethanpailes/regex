
// required for the benchmarker
#![feature(test)]

extern crate test;
extern crate rand;
extern crate lipsum;

mod freqs;
use freqs::BYTE_FREQUENCIES;

use rand::Rng;

macro_rules! string_searcher_benches {
    ($mod_name:ident, $haystack_size:expr,
     $needle_size:expr, $searcher:ident) => {
        mod $mod_name {
            extern crate boyer_moore;
            use test::Bencher;

            use self::boyer_moore::{$searcher, StringSearcher};

            /*
            /// Benchmark on some randomly generated data. Directly
            /// inspired by ripgrep-617.
            ///
            /// Note that we expect this to be slower than search on
            /// natural language because it will defeat any frequency
            /// analysis optimizations.
            ///
            /// Technically the needle might appear in the haystack
            /// before the point where we place it, but we are just
            /// going to have faith that the $needle_size is long
            /// enough that we won't have any collisions.
            #[bench]
            fn bench_random_bytes(b: &mut Bencher) {
                bench_string_searcher(b,
                    super::random_byte_vec,
                    super::random_byte_vec);
            }

            /// Benchmark searching on a randomly generated, natural language 
            /// lookin' haystack.
            ///
            /// This guy is probably not going to be that stable, but
            /// I include it as a sanity check to make sure that we
            /// aren't somehow overfitting to the sherlock test.
            #[bench]
            fn bench_lorum_ipsum(b: &mut Bencher) {
                bench_string_searcher(b,
                    super::lipsum_exact_bytes,
                    super::lipsum_needle_exact_bytes);
            }

            /// Benchmark searching within the sherlock text.
            ///
            /// This is here to display search characteristics on
            /// a haystack composed of natural language.
            #[bench]
            fn bench_sherlock(b: &mut Bencher) {
                bench_string_searcher(b,
                    super::sherlock_gen_haystack,
                    super::lipsum_exact_bytes);
            }
            */

            #[bench]
            fn bench_uncommon_needle(b: &mut Bencher) {
                bench_string_searcher(b,
                    super::sherlock_gen_haystack,
                    super::all_uncommon);
            }

            fn bench_string_searcher<F1, F2>(
                b: &mut Bencher,
                gen_random_haystack: F1,
                gen_random_needle: F2,
            ) 
                where F1: Fn(usize) -> Vec<u8>,
                      F2: Fn(usize) -> Vec<u8>
            {
                let hsize: usize = $haystack_size;
                let nsize: usize = $needle_size;
                let needle_start: usize = hsize - nsize;

                let mut haystack = gen_random_haystack(needle_start);
                let needle = gen_random_needle(nsize);

                let searcher = $searcher::new(needle.as_slice());
                haystack.extend(needle.clone());

                b.iter(|| {
                    match searcher.find(haystack.as_slice()) {
                        Some(off) => (),//assert_eq!(needle_start, off),
                        None =>
                            panic!("Needle not found. (needle={:?}).", needle),
                    }
                });
            }


        }
    }
}

fn random_byte_vec(len: usize) -> Vec<u8> {
    let mut rng = rand::thread_rng();

    let mut vec: Vec<u8> = Vec::with_capacity(len);
    for _ in 0..len {
        vec.push(rng.gen());
    }

    vec
}

fn lipsum_exact_bytes(n: usize) -> Vec<u8> {
    use lipsum::lipsum;

    let mut ret: String = String::from("");
    while ret.len() < n {
        let ret_len = ret.len();

        let next = lipsum( ((n - ret_len) / 7) + 1 );
        if next.len() >= n - ret_len {
            ret.push_str(&next[0..(n - ret_len)]);
        } else {
            ret.push_str(next.as_str());
        }
    }

    ret.as_bytes().iter().map(|x| *x).collect::<Vec<_>>()
}

fn lipsum_needle_exact_bytes(n: usize) -> Vec<u8> {
    let spool = b"None of these words show up in the random text that gets autogenerated by the markov chain in the filler words crate we use. It is pretty hard to write about it without actually mentioning it by name. Anyway, we will start repeating words if a needle that is too long is requested, but hopefully this is good enough.";
    spool_bytes(n, spool)
}

fn sherlock_gen_haystack(n: usize) -> Vec<u8> {
    let sherlock = include_str!("../../../bench/src/data/sherlock.txt").to_owned();
    spool_bytes(n, sherlock.as_bytes())
}

fn all_uncommon(n: usize) -> Vec<u8> {
    use std::iter::repeat;
    const RANK: usize = 242; //253;
    fn freq_rank(b: u8) -> usize { BYTE_FREQUENCIES[b as usize] as usize }

    let c = (0..255).filter(|b| freq_rank(*b) == RANK).nth(0).unwrap();

    spool_bytes(n, repeat(c).take(100).collect::<Vec<_>>().as_slice())
}

fn spool_bytes(n: usize, spool: &[u8]) -> Vec<u8> {
    let mut ret = Vec::with_capacity(n);

    let mut i = 0;
    while ret.len() < n {
        ret.push(spool[i]);
        i = (i + 1) % spool.len();
    }

    ret
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn lipsum_smoke_test() {
        let lip = lipsum_exact_bytes(10);
        assert_eq!(lip.len(), 10);
    }

    #[test]
    fn lipsum_needle_smoke_test() {
        let lipn = lipsum_needle_exact_bytes(10);
        assert_eq!(lipn.len(), 10);
    }
}

string_searcher_benches!(
    bm_h1000000n10, 1000000, 10, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n21, 1000000, 21, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n100, 1000000, 100, BoyerMooreSearcher);

/*
string_searcher_benches!(
    bm_h1000000n40, 1000000, 40, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n50, 1000000, 50, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n60, 1000000, 60, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n70, 1000000, 70, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n80, 1000000, 80, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n90, 1000000, 90, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n100, 1000000, 100, BoyerMooreSearcher);
string_searcher_benches!(
    bm_h1000000n1000, 1000000, 1000, BoyerMooreSearcher);
    */



/*
string_searcher_benches!(
    memchr_h1000000n10, 1000000, 10, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n20, 1000000, 20, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n30, 1000000, 30, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n40, 1000000, 40, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n50, 1000000, 50, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n60, 1000000, 60, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n70, 1000000, 70, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n80, 1000000, 80, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n90, 1000000, 90, MemchrSearcher);
string_searcher_benches!(
    memchr_h1000000n100, 1000000, 100, MemchrSearcher);
*/


